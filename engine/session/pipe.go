package session

import (
	"context"
	"errors"
	fmt "fmt"
	io "io"
	"os"
	"runtime/debug"

	"github.com/dagger/dagger/engine/session/ctxio"
	"github.com/moby/buildkit/util/grpcerrors"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
)

// PipeAttachable implements the PipeServer interface generated by protoc.
type PipeAttachable struct {
	rootCtx context.Context

	stdin  io.Reader
	stdout io.Writer

	UnimplementedPipeServer
}

type debugIO struct {
	io.Reader
	io.Writer
}

func (d debugIO) Write(p []byte) (int, error) {
	fmt.Fprintln(os.Stderr, "+ğŸdebugIOâœï¸", string(p))
	defer fmt.Fprintln(os.Stderr, "-ğŸdebugIOâœï¸")
	return d.Writer.Write(p)
}

func (d debugIO) Read(p []byte) (int, error) {
	fmt.Fprintln(os.Stderr, "+ğŸdebugIOğŸ“–", string(p))
	defer fmt.Fprintln(os.Stderr, "-ğŸdebugIOğŸ“–")
	return d.Reader.Read(p)
}

func NewPipeAttachable(rootCtx context.Context, stdin io.Reader, stdout io.Writer) PipeAttachable {
	d := debugIO{stdin, stdout}
	return PipeAttachable{
		rootCtx: rootCtx,
		stdin:   d,
		stdout:  d,
	}
}

func (p PipeAttachable) Register(srv *grpc.Server) {
	RegisterPipeServer(srv, p)
}

func (p PipeAttachable) IO(srv Pipe_IOServer) error {
	ctx := p.rootCtx
	pio := &PipeIO{GRPC: srv}
	go io.Copy(pio, ctxio.NewReader(ctx, p.stdin))
	_, err := io.Copy(p.stdout, ctxio.NewReader(ctx, pio))
	return err
}

// PipeIO transforms a Pipe_IOServer or a Pipe_IOClient into an io.ReadWriter
type PipeIO struct {
	GRPC interface {
		Send(*Data) error
		Recv() (*Data, error)
	}
	rem []byte // remainder buffer
}

func (pio *PipeIO) Write(p []byte) (n int, err error) {
	fmt.Fprintln(os.Stderr, "+ğŸPipeIOâœï¸", string(p), string(debug.Stack()))
	defer fmt.Fprintln(os.Stderr, "-ğŸPipeIOâœï¸", string(debug.Stack()))
	err = pio.GRPC.Send(&Data{Data: p})
	if err != nil {
		return 0, fmt.Errorf("error writing dagger pipe: %w", err)
	}
	return len(p), nil
}

func (pio *PipeIO) Read(p []byte) (n int, err error) {
	fmt.Fprintln(os.Stderr, "+ğŸPipeIOğŸ“–", string(p), string(debug.Stack()))
	defer fmt.Fprintln(os.Stderr, "-ğŸPipeIOğŸ“–", string(debug.Stack()))
	// read from the remainder buffer first
	n = copy(p, pio.rem)
	p = p[n:]
	pio.rem = pio.rem[n:]
	if len(p) == 0 || n != 0 {
		return n, nil
	}
	req, err := pio.GRPC.Recv()
	if err != nil {
		// Return io.EOF in certain cases to conform to io.Reader
		//
		// The following conditionals were copied and modified manually from the Terminal session attachable,
		// where `nil` was being returned as opposed to `io.EOF` returned here.
		// The reason for discrepancy is because this is an attempt to simplify the logic using io.Copy, io.Reader
		// interfaces which mandate io.EOF here.
		// In the future, terminal session attachable may also get refactored using this simplified logic.
		if errors.Is(err, context.Canceled) || grpcerrors.Code(err) == codes.Canceled {
			// canceled
			return 0, io.EOF
		}
		if errors.Is(err, io.EOF) {
			// stopped
			return 0, io.EOF
		}
		if grpcerrors.Code(err) == codes.Unavailable {
			// client disconnected (i.e. quitting Dagger out)
			return 0, io.EOF
		}
		return 0, fmt.Errorf("error reading dagger pipe: %w", err)
	}
	pio.rem = req.GetData()
	n = copy(p, pio.rem)
	pio.rem = pio.rem[n:]
	return n, nil
}

func (pio *PipeIO) Close() error {
	if c, ok := pio.GRPC.(interface {
		CloseSend() error
	}); ok {
		return c.CloseSend()
	}
	return nil
}
