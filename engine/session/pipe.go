package session

import (
	"context"
	"errors"
	fmt "fmt"
	io "io"
	"os"

	"github.com/dagger/dagger/engine/session/ctxio"
	"github.com/moby/buildkit/util/grpcerrors"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
)

// PipeAttachable implements the PipeServer interface generated by protoc.
type PipeAttachable struct {
	rootCtx context.Context

	stdin  io.Reader
	stdout io.Writer

	UnimplementedPipeServer
}

func NewPipeAttachable(rootCtx context.Context, stdin io.Reader, stdout io.Writer) PipeAttachable {
	return PipeAttachable{
		rootCtx: rootCtx,
		stdin:   stdin,
		stdout:  stdout,
	}
}

func (p PipeAttachable) Register(srv *grpc.Server) {
	RegisterPipeServer(srv, p)
}

func (p PipeAttachable) IO(srv Pipe_IOServer) error {
	ctx, cancel := context.WithCancel(p.rootCtx)
	rw := ctxio.NewReadWriter(ctx, &PipeIO{GRPC: srv})
	defer cancel()

	go func() {
		_, err := io.Copy(rw, p.stdin)
		if err != nil {
			fmt.Fprintf(os.Stderr, "pipeattachable stdin copy: %v\n", err)
		}
		cancel()
	}()
	fmt.Fprintln(os.Stderr, "PipeAttachable.IO start stdout copy")
	if _, err := io.Copy(p.stdout, rw); err != nil {
		fmt.Fprintf(os.Stderr, "pipeattachable stdout copy: %v\n", err)
	}
	fmt.Fprintln(os.Stderr, "PipeAttachable.IO done")
	return nil
}

// PipeIO transforms a Pipe_IOServer or a Pipe_IOClient into an io.ReadWriter
type PipeIO struct {
	GRPC interface {
		Send(*Data) error
		Recv() (*Data, error)
	}
	rem []byte
}

func (w *PipeIO) Write(p []byte) (n int, err error) {
	err = w.GRPC.Send(&Data{Data: p})
	n = len(p)
	if err == nil {
		return n, nil
	}
	// Return io.EOF to conform to io.Writer
	if errors.Is(err, io.EOF) {
		return n, io.EOF
	}
	return n, fmt.Errorf("error writing dagger pipe: %w", err)
}

func (r *PipeIO) Read(p []byte) (n int, err error) {
	// read from the remainder buffer first
	n = copy(p, r.rem)
	p = p[n:]
	r.rem = r.rem[n:]
	if len(p) == 0 || n != 0 {
		return n, nil
	}
	req, err := r.GRPC.Recv()
	if err != nil {
		// Return io.EOF in certain cases to conform to io.Reader
		if errors.Is(err, context.Canceled) || grpcerrors.Code(err) == codes.Canceled {
			// canceled
			return 0, io.EOF
		}
		if errors.Is(err, io.EOF) {
			// stopped
			return 0, io.EOF
		}
		if grpcerrors.Code(err) == codes.Unavailable {
			// client disconnected (i.e. quitting Dagger out)
			return 0, io.EOF
		}
		return 0, fmt.Errorf("error reading dagger pipe: %w", err)
	}
	r.rem = req.GetData()
	n = copy(p, r.rem)
	r.rem = r.rem[n:]
	return n, nil
}

func (p *PipeIO) Close() error {
	fmt.Fprintln(os.Stderr, "+PipeIO.Close")
	defer fmt.Fprintln(os.Stderr, "-PipeIO.Close")
	if c, ok := p.GRPC.(interface {
		CloseSend() error
	}); ok {
		return c.CloseSend()
	}
	return nil
}
